- domanda: "Which numeric type is a valid MongoDB BSON type?"
  risposte:
    a: "Float"
    b: "Number"
    c: "BIGINT"
    d: "32-bit integer"
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: "Given the following documents in a collection, which two documents can successfully be added in the same collection?"
  codeBlock: |
      { _id: 1, n: [1,2,5], p: 0.75, c: 'Green' },
      { _id: 2, n: 'Orange', p: 'Blue', c: 42, q: 14 },
      { _id: 3, n: [1,3,7], p: 0.85, c: 'Orange' }
  risposte:
    a: "{ _id: 1, n: [1,2,5], p: 0.75, c: 'Green' }"
    b: "{ _id: 5, n: [1,2,5], p: 0.75, c: 'Green' }"
    c: "{ _id: 2, n: [1,2,5], p: 0.75, c: 'Green' }"
    d: "{ _id: 6, n: [1,3,7], p: 0.85, c: 'Orange }"
  rispostaCorretta: ["b","d"]
  origin: "mongodbUniversity"

- domanda: "Given the following documents in a collection, which two documents can successfully be added in the same collection?"
  codeBlock: |
      {_id: 1, txt: "just some text"},
      {_id: 2, txt: "just some text"}
  risposte:
    a: '{_id: 0, txt: "just some text"}'
    b: '{_id: 1, txt: "just some text"}'
    c: '{_id: [4], txt: "just some text"}'
    d: '{_id: 3, txt: "just some text"}'
  rispostaCorretta: ["a","d"]
  origin: "mongodbUniversity"

- domanda: "Given the following document, what command will properly add this document to the files collection using mongosh?"
  codeBlock: |
      The name is a.log, the owner of the file is applicationA, the size of the file is 1KB, and the file was deleted.
  risposte:
    a: 'db.files.insertOne({ file: "a.log", owner: "applicationA", size: 1KB, deleted: true })'
    b: 'db.files.insertOne({ file: "a.log", owner: "applicationA", size: 1KB, deleted: True })'
    c: 'db.files.insertOne({ file: "a.log", owner: "applicationA", size: 1024, deleted: true })'
    d: 'db.files.insertOne({ file: "a.log", owner: "applicationA", size: 1024, deleted: True })'
  rispostaCorretta: "c"
  origin: "mongodbUniversity"
  
- domanda: "Given the following sample documents in products collection and the query, what is the correct output of the query?"
  codeBlock: |
      { "name" : "XPhone", "price" : 799, "color" : [ "white", "black" ], "storage" : [ 64, 128, 256 ] },
      { "name" : "XPad", "price" : 899, "color" : [ "white", "black", "purple" ], "storage" : [ 128, 256, 512 ] },
      { "name" : "GTablet", "price" : 899, "color" : [ "blue" ], "storage" : [ 16, 64, 128 ] },
      { "name" : "GPad", "price" : 699, "color" : [ "white", "orange", "gold", "gray" ], "storage" : [ 128, 256, 1024 ] },
      { "name" : "GPhone", "price" : 599, "color" : [ "white", "orange", "gold", "gray" ], "storage" : [ 128, 256, 512 ] }

      db.products.find({$and : [{"price" : {$lte : 800}},
                                       {$or : [{"color" : "purple"}, {"storage" : 1024}]}]})
  risposte:
    a: '{ "name" : "XPhone", "price" : 799, "color" : [ "white", "black" ], "storage" : [ 64, 128, 256 ] }'
    b: '{ "name" : "XPad", "price" : 899, "color" : [ "white", "black", "purple" ], "storage" : [ 128, 256, 512 ] }'
    c: '{ "name" : "GPhone", "price" : 599, "color" : [ "white", "orange", "gold", "gray" ], "storage" : [ 128, 256, 512 ] }'
    d: '{ "name" : "GPad", "price" : 699, "color" : [ "white", "orange", "gold", "gray" ], "storage" : [ 128, 256, 1024 ] }'
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: "An `inventory` collection consists of 200 documents. What method should be used to get all documents from a cursor using mongosh?"
  risposte:
    a: "db.inventory.findOne()"
    b: "db.inventory.find().toArray();"
    c: "db.inventory.find();"
    d: "db.inventory.findMany().toArray()"
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "A collection has documents like the following. How should the 'autocomplete' index be defined to look for matches at the beginning of a word on the name field?"
  codeBlock: |
      { _id: 1, name: 'Oatmeal Fruit Cake with Gummy Bears ', price: 11)},
      { _id: 2, name: 'Cheesecake Trifle with Chocolate Sprinkles ', price: 14)},
      { _id: 3, name: 'Pistachio Brownie with Walnuts ', price: 5},
      { _id: 4, name: 'Strawberry Ice Cream Cake with Butterscotch Syrup ', price: 3)}
  risposte:
    a: '{  "mappings": {    "dynamic": false,    "fields": {         "name": [   {  "type": "autocomplete",                              "tokenization": "regexCaptureGroup"} ]     } }}'
    b: '{  "mappings": {    "dynamic": false,    "fields": {         "name": [   {  "type": "autocomplete",                              "tokenization": "edgeGram"} ]    } }}'
    c: '{  "mappings": {    "dynamic": false,    "fields": {         "name": [   {  "type": "autocomplete",                              "tokenization": "nGram"} ]    } }}'
    d: '{  "mappings": {    "dynamic": false,    "fields": {         "name": [   {  "type": "autocomplete",                              "tokenization": "matchNGram"}} ]     } }}'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "Given the following sample documents,a company wants to create a mobile app for users to find restaurants by name. The developer wants to show the user restaurants that match their search. An Atlas Search index has already been created to support this query. What query satisfies these requirements?"
  codeBlock: |
      {_id:1, name: "Quesedillas Inc.", active: true },
      {_id:2, name: "Pasta Inc.", active: true },
      {_id:3, name: "Tacos Inc.", active: false },
      {_id:4, name: "Cubanos Inc.", active: false },
      {_id:5, name: "Chicken Parm Inc.", active: false }
  risposte:
    a: 'db.restaurants.aggregate([{    "$search": {      "text": { "path": "name", "synonym": "cuban"}    } }])'
    b: 'db.restaurants.aggregate([{    "$search": {      "text": { "path": "name", "query": "cuban"}    } }])'
    c: 'db.restaurants.aggregate([{    "$search": {      "text": { "field": "name", "query": "cuban"}    } }])'
    d: 'db.restaurants.aggregate([{    "$search": {      "text": { "field": "name", "synonym": "cuban"}    } }])'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "Given the data set and query, what is the output?"
  codeBlock: |
      { "_id" : ObjectId("512bc95fe835e68f199c8686"), "player" : "p1", "score" : 89 }
      { "_id" : ObjectId("512bc962e835e68f199c8687"), "player" : "p2", "score" : 85 }
      { "_id" : ObjectId("55f5a192d4bede9ac365b257"), "player" : "p2", "score" : 65 }
      { "_id" : ObjectId("55f5a192d4bede9ac365b258"), "player" : "p3", "score" : 65 }
      { "_id" : ObjectId("55f5a1d3d4bede9ac365b259"), "player" : "p3", "score" : 75 }
      { "_id" : ObjectId("55f5a1d3d4bede9ac365b25a"), "player" : "p5", "score" : 70 }
      { "_id" : ObjectId("55f5a1d3d4bede9ac365b25b"), "player" : "p6", "score" : 100 }

      db.scores.aggregate(
      [{ $group: {
            _id: '$player',
            score: {
                $avg: '$score'
            }
      },
      { $match: {
          score: { 
                  $gt: 70
            }
      }
      ])
  risposte:
    a: '{ "player" : "p1", "score" : 89 } { "player" : "p2", "score" : 85 } { "player" : "p3", "score" : 75 } { "player" : "p6", "score" : 100 }'
    b: '{ "player" : "p1", "score" : 89 } { "player" : "p2", "score" : 75 } { "player" : "p6", "score" : 100 }'
    c: '{ "player" : "p1", "score" : 89 } { "player" : "p2", "score" : 75 } { "player" : "p3", "score" : 70 } { "player" : "p5", "score" : 70 } { "player" : "p6", "score" : 100 }'
    d: '{ "player" : "p1", "score" : 89 } { "player" : "p2", "score" : 75 } { "player" : "p3", "score" : 70 } { "player" : "p6", "score" : 100 }'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "A collection coll in database mdb has the following documents. After executing the given aggregation pipeline what are two expected results?"
  codeBlock: |
      db.getSiblingDB("mdb").coll.aggregate([
          { $out: {db:'test', collection:'results'}} ])
  risposte:
    a: "Collection `results` is created in database `test`."
    b: "There is a syntax error command. Collection `results` is not created."
    c: "No documents in collection `coll` are written to collection `results`."
    d: "All documents in collection `coll` are written to collection `results`."
  rispostaCorretta: ["b", "c"]
  origin: "mongodbUniversity"

- domanda: "Given the following documents, if the following command is executed, what is the result?"
  codeBlock: |
      {_id:1, a: "one", b: "four"}
      {_id:2, a: "two", b: "four"}
      {_id:3, a: "three", b: "four", c: "three"}

      db.coll.replaceOne({}, {a: "ten", b: "five"})
  risposte:
    a: '{_id:1, a: "ten", b: "five"} {_id:2, a: "ten", b: "five"} {_id:3, a: "ten", b: "five"}'
    b: '{_id:1, a: "ten", b: "five"} {_id:2, a: "two", b: "four"} {_id:3, a: "three", b: "four", c: "three"}'
    c: '{_id:1, a: "ten", b: "five"} {_id:2, a: "ten", b: "five"} {_id:3, a: "ten", b: "five", c: "three"}'
    d: '{_id:1, a: "one", b: "four"} {_id:2, a: "two", b: "four"} {_id:3, a: "three", b: "four", c: "three"}'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "Given the collection called coll, with only the following documents, the update operation db.coll.updateMany({},{$set:{b:2}}) successfully completes. What is the output of db.coll.find()?"
  codeBlock: |
    {
      _id:1,
      a:1,
      b:1
    },
    {
      _id:2,
      a:2
    }
  risposte:
    a: "[{_id:1,  b:2}, {_id:2,  b:2}]"
    b: "[{_id:1,  a:1,  b:2}, {_id:2,  a:2}]"
    c: "[{_id:1,  a:1,  b:1}, {_id:2,  a:2,  b:2}]"
    d: "[{_id:1,  a:1,  b:2}, {_id:2,  a:2,  b:2}]"
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: "Given the following documents, if the following command is executed, what is the result?"
  codeBlock: |
      {_id:1, a: "one", b: "four"}
      {_id:2, a: "two", b: "four"}
      {_id:3, a: "three", b: "four", c: "three"}

      db.coll.replaceOne({}, {a: "ten", b: "five"})
  risposte:
    a: '{_id:1, a: "ten", b: "five"} {_id:2, a: "ten", b: "five"} {_id:3, a: "ten", b: "five"}'
    b: '{_id:1, a: "ten", b: "five"} {_id:2, a: "two", b: "four"} {_id:3, a: "three", b: "four", c: "three"}'
    c: '{_id:1, a: "ten", b: "five"} {_id:2, a: "ten", b: "five"} {_id:3, a: "ten", b: "five", c: "three"}'
    d: '{_id:1, a: "one", b: "four"} {_id:2, a: "two", b: "four"} {_id:3, a: "three", b: "four", c: "three"}'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "Given the collection called coll, with only the following documents, The update operation db.coll.updateMany({},{$set:{b:2}}) successfully completes. What is the output of db.coll.find()?"
  codeBlock: |
      {
        _id:1,
        a:1,
        b:1
      },
      {
        _id:2,
        a:2
      }
  risposte:
    a: "[{_id:1,  b:2}, {_id:2,  b:2}]"
    b: "[{_id:1,  a:1,  b:2}, {_id:2,  a:2}]"
    c: "[{_id:1,  a:1,  b:1}, {_id:2,  a:2,  b:2}]"
    d: "[{_id:1,  a:1,  b:2}, {_id:2,  a:2,  b:2}]"
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: 'Given the following document from the cakeFlavors collection. All documents in this collection have the same schema. What operation on the cakeFlavors collection will update the value of the number field to 100 for a document with a "strawberry" flavor value and insert a new document if it does not exist?'
  codeBlock: |
      {
        "_id" : 1,
        "flavor" : "chocolate",
        "number" : 15
      }
  risposte:
    a: 'db.cakeFlavors.updateOne({ flavor: "strawberry"} , { $set: { number: 100 } }, { $upsert: true })'
    b: 'db.cakeFlavors.insertOne({ flavor: "strawberry"} , { $set: { number: 100 } }, { $upsert: true })'
    c: 'db.cakeFlavors.insertOne({ flavor: "strawberry"} , { $set: { number: 100 } }, { upsert: true })'
    d: 'db.cakeFlavors.updateOne({ flavor: "strawberry"} , { $set: { number: 100 } }, { upsert: true })'
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: "Given the following example document from the movie collection. All documents in this collection have the same schema. What command updates the value of the classic field to true for all documents with a year value less than 2000?"
  codeBlock: |
      {
        _id: ObjectId("62872ccd590c3c06d78af00d"),
        genres: [ "Drama", "Romance", "War" ],
        title: "A.B.",
        year: 1921,
        tomatoes: { rating: 3.9, votes: 507, id: "76" },
        countries: [ "USA" ],
        classic : false
      }
  risposte:
    a: "db.movie.updateOne({ year: { $lt: 2000 } }, { $set: { classic: true } }, { multi: true })"
    b: "db.movie.updateMany({ year: { $lt: 2000 } }, { $set: { classic: true } })"
    c: "db.movie.updateMulti({ year: { $lt: 2000 } }, { $set: { classic: true } })"
    d: "db.movie.updateBulk({ year: { $lt: 2000 } }, { $set: { classic: true } })"
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: 'Given the following sample documents in the loans collection. What command deletes the document where the value of book is "EFF" and user is "T.B.", and returns the deleted document?'
  codeBlock: |
      { _id: 122, book: "ABC", name: "L.A.", date: ISODate("2022-05-20") },
      { _id: 343, book: "EFF", name: "T.B.", date: ISODate("2022-05-22") },
      { _id: 454, book: "CFH", name: "M.C.", date: ISODate("2022-05-12") }
  risposte:
    a: 'db.loans.deleteOne( { book: "EFF", name: "T.B." } )'
    b: 'db.loans.findOneAndDelete( { book: "EFF", name: "T.B." } )'
    c: 'db.loans.remove( { book: "EFF", name: "T.B." } , {returnDocument: true} )'
    d: 'db.loans.deleteOne( { book: "EFF", name: "T.B." }, {returnDocument: true} )'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: 'Given the following sample documents in the inventory collection. What expression will remove all documents with "status" : "C" in the inventory collection?'
  codeBlock: |
      { _id: 6305, name : "A. S.", "assignment" : 5, "status" : "A" },   
      { _id: 6308, name : "B. M.", "assignment" : 3, "status" : "B" },   
      { _id: 6312, name : "E. M.", "assignment" : 5, "status" : "C" },   
      { _id: 6319, name : "R. S.", "assignment" : 2, "status" : "D" },   
      { _id: 6322, name : "A. S.", "assignment" : 2, "status" : "A" },   
      { _id: 6234, name : "R. S.", "assignment" : 1, "status" : "B" },
      { _id: 6235, name : "A. S.", "assignment" : 1, "status" : "C" },
      { _id: 6315, name : "E. M.", "assignment" : 3, "status" : "A" }
  risposte:
    a: 'db.inventory.delete ({"status" : "C"})'
    b: 'db.inventory.deleteOne ({"status" : "C"})'
    c: 'db.inventory.deleteMany ({"status" : "C"})'
    d: 'db.inventory.findOneAndDelete ({"status" : "C"})'
  rispostaCorretta: "c"
  origin: "mongodbUniversity"

- domanda: 'Given the following documents in the ratings collection. What mongosh command will return a document for hotel "CCC"?'
  codeBlock: |
      { _id: 0, hotel: "AAA", rating: 4.5 },
      { _id: 1, hotel: "BBB", rating: 3.0 },
      { _id: 2, hotel: "CCC", rating: 4.2 }
  risposte:
    a: 'db.ratings.return_one( {hotel: "CCC"} )'
    b: 'db.ratings.find_one( {hotel: "CCC"} )'
    c: 'db.ratings.returnOne( {hotel: "CCC"} )'
    d: 'db.ratings.findOne( {hotel: "CCC"} )'
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: "The following query generates a collection scan. Which two indexes will most improve the performance of the query?"
  codeBlock: |
      db.people.find({employer : "ABC" }).sort ({last_name:1 , job:1})
  risposte:
    a: "db.people.createIndex({employer:1, last_name : 1  , job : 1 } )"
    b: "db.people.createIndex({employer:1, last_name : -1  , job : -1 } )"
    c: "db.people.createIndex({employer:1,last_name : -1  , job : 1 } )"
    d: "db.people.createIndex({employer:1,last_name : 1  , job : -1 } )"
  rispostaCorretta: ["a", "b"]
  origin: "mongodbUniversity"

- domanda: "Given a collection called collection, in which all documents have the following shape and the query on this collection. What index will support this query?"
  codeBlock: |
      {
        _id:1,
        objs:[
          {a:1,b:2},{a:2,b:1}
        ] 
      }

      db.collection.find({"objs.a":1})
  risposte:
    a: '{"objs.a":1}'
    b: '{objs:1}'
    c: '{objs:1,"objs.a"1}'
    d: '{objs:1,"a"1}'
  rispostaCorretta: "a"
  origin: "mongodbUniversity"

- domanda: "Given the following query, which two indexes will improve the performance of this query?"
  codeBlock: |
      db.coll.find({}).sort({"product": 1, "price": 1})
  risposte:
    a: '{"product": 1, "price": 1}'
    b: '{"product": 1, "price": -1}'
    c: '{"product": -1, "price": 1}'
    d: '{"product": -1, "price": -1}'
  rispostaCorretta: ["a","d"]
  origin: "mongodbUniversity"

- domanda: "Given the following query, which two indexes improve the performance of this query the most?"
  codeBlock: |
      db.coll.find({}).sort({"product": 1, "price": 1})
  risposte:
    a: "{ v: 2, key: { price: 1, product: 1 }, name: 'price_1_product_1' }"
    b: "{ v: 2, key: { product: 1, price: 1 }, name: 'product_1_price_1' }"
    c: "{ v: 2, key: { price: -1, product: -1 }, name: 'price_-1_product_-1' }"
    d: "{ v: 2, key: { product: -1, price: -1 }, name: 'product_-1_price_-1' }"
  rispostaCorretta: ["b", "d"]
  origin: "mongodbUniversity"

- domanda: "What mongosh command shows how many indexes are associated with an inventory collection?"
  risposte:
    a: "db.inventory.getIndexes()"
    b: "db.inventory.showIndexes()"
    c: "db.inventory.displayIndexes()"
    d: "db.inventory.indexes()"
  rispostaCorretta: "a"
  origin: "mongodbUniversity"

- domanda: "A typical products collection is in an e-commerce database. What schema is the most effective?"
  risposte:
    a: "Orders for products should be embedded as an array in each product document."
    b: "Reviews for products should be embedded as an array in each product document."
    c: "Current and historical prices for product should be embedded in each product document."
    d: "Current inventory/availability for product should be embedded in each product document."
  rispostaCorretta: "d"
  origin: "mongodbUniversity"

- domanda: "A Cooking dataset is in Atlas. There is a Recipes database with a Desserts collection. How can one document be found that provides a recipe for cookies without chocolate using Atlas Data Explorer?"
  risposte:
    a: '1. Select the collection on the left-hand side. 2. Select the "Aggregation" view. 3. Specify the first stage as `$match` query: {dessert_type: "Cookie"} ``` 4. Specify the second stage as `$match` query: ``` {ingredients: {$all: ["chocolate"]}} 5. Set `$limit` to 1.'
    b: '1. Select the collection on the left-hand side. 2. Select the "Aggregation" view. 3. Specify the first stage as `$match` query: ``` {dessert_type: "Cookie", ingredients: {$nin: ["chocolate"]}} ``` 4. Set `$limit` to 1.'
    c: '1. Select the collection on the left-hand side. 2. Specify the "Find" view. 3. Specify the filter query: ``` {dessert_type: "Cookie", ingredients: {$nin: ["chocolate"]} ``` 4. Specify the project query: ``` {dessert_type: 1}'
    d: '1. Select the collection on the left-hand side. 2. Specify the "Find" view. 3. Specify the filter query with limit: ``` {dessert_type: "Cookie", ingredients: {$nin: ["chocolate"], $limit: 1}'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "What are two valid method names for the MongoClient class?"
  risposte:
    a: "close()"
    b: "open()"
    c: "destroy()"
    d: "getDatabase()"
  rispostaCorretta: ["a","d"]
  origin: "mongodbUniversity"

- domanda: "What are two advantages to using Connection Pooling within the Java Driver?"   
  risposte:
    a: "Reduce the latency for an application."
    b: "Limit the number of connections to the server."
    c: "Remove the need for the application to authenticate."
    d: "Remove the need to open and close connections in the application."
  rispostaCorretta: ["a","b"]
  origin: "mongodbUniversity"

- domanda: "Assuming correct imports, properly instantiated MongoClient called client, and given the following Java code. What is the correct syntax for updating multiple documents with a single command?"
  codeBlock: |
      MongoCollection collection = client.getDatabase("employees").getCollection("records");
      Bson filter = eq("position", "Developer Advocate");
      Bson update = set("position", "Developer Evangelist");
  risposte:
    a: "collection.UpdateMany(update, filter);"
    b: "collection.UpdateMany(filter, update);"
    c: "collection.UpdateMultiple(update, filter);"
    d: "collection.UpdateMultiple(filter, update);"
  rispostaCorretta: "b"
  origin: "mongodbUniversity"

- domanda: "Given the following sample documents. A company wants to create a mobile app for users to find restaurants by name. The developer wants to show the user restaurants that match their search. An Atlas Search index has already been created to support this query. What query satisfies these requirements?"
  codeBlock: |
      {_id:1, name: "Quesedillas Inc.", active: true },
      {_id:2, name: "Pasta Inc.", active: true },
      {_id:3, name: "Tacos Inc.", active: false },
      {_id:4, name: "Cubanos Inc.", active: false },
      {_id:5, name: "Chicken Parm Inc.", active: false }
  risposte:
    a: 'db.restaurants.aggregate([{    "$search": {      "text": { "path": "name", "synonym": "cuban"}    } }])'
    b: 'db.restaurants.aggregate([{    "$search": {      "text": { "path": "name", "query": "cuban"}    } }])'
    c: 'db.restaurants.aggregate([{    "$search": {      "text": { "field": "name", "query": "cuban"}    } }])'
    d: 'db.restaurants.aggregate([{    "$search": {      "text": { "field": "name", "synonym": "cuban"}    } }])'
  rispostaCorretta: "b"
  origin: "mongodbUniversity"
